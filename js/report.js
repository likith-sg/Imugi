import { appState } from './state.js';
import { showNotification } from './ui.js';
import { inferColumnTypes, generateDatasetSummary } from './data.js';

export function renderChart(chartDef, chartId) {
    const terminalBody = document.getElementById('terminal-body');
    const container = document.createElement('div');
    container.style.cssText = "position: relative; padding: 1rem; background-color: var(--bg-primary); border-radius: 0.5rem; margin: 1rem 0; height: 450px;";
    const canvas = document.createElement('canvas');
    canvas.id = chartId;
    container.appendChild(canvas);
    const controls = document.createElement('div');
    controls.style.cssText = "text-align: center; margin-top: 0.5rem; display:flex; gap: 0.5rem; justify-content: center; flex-wrap: wrap;";
    ['bar', 'line', 'pie', 'doughnut', 'scatter', 'bubble', 'radar', 'polarArea'].forEach(type => {
        const btn = document.createElement('button');
        btn.className = 'btn btn-secondary';
        btn.style.padding = '0.25rem 0.5rem';
        btn.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        btn.onclick = () => switchChartType(chartId, type);
        controls.appendChild(btn);
    });
    container.appendChild(controls);
    terminalBody.appendChild(container);
    const textColor = document.body.dataset.theme === 'dark' ? '#f9fafb' : '#0f172a';
    const finalOptions = {
        ...chartDef.options,
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            ...chartDef.options?.plugins,
            title: { display: true, text: chartDef.options?.plugins?.title?.text || 'Generated Chart', color: textColor, font: { size: 16 } },
            legend: { labels: { color: textColor } },
            datalabels: {
                color: document.body.dataset.theme === 'dark' ? '#e5e7eb' : '#374151',
                anchor: 'end',
                align: 'end',
                formatter: (value) => (typeof value === 'object' && value !== null) ? `(${value.x}, ${value.y})` : value
            }
        },
        scales: {
            x: { ...chartDef.options?.scales?.x, ticks: { color: textColor }, title: { ...chartDef.options?.scales?.x?.title, display: !!chartDef.options?.scales?.x?.title?.text, color: textColor } },
            y: { ...chartDef.options?.scales?.y, ticks: { color: textColor }, title: { ...chartDef.options?.scales?.y?.title, display: !!chartDef.options?.scales?.y?.title?.text, color: textColor } }
        }
    };
    new Chart(canvas, { type: chartDef.type, data: chartDef.data, options: finalOptions });
    terminalBody.scrollTop = terminalBody.scrollHeight;
}

function switchChartType(canvasId, newType) {
    const chart = Chart.getChart(canvasId);
    if (chart) {
        chart.config.type = newType;
        chart.update();
    }
}

export function generateReport() {
    const modal = document.getElementById('report-modal');
    const slidesContainer = document.getElementById('report-slides');
    slidesContainer.innerHTML = ''; let slideIndex = 0; const slidesContent = [];
    const dataset = appState.datasets[appState.activeDataset];
    if (!dataset || !dataset.data || dataset.data.length === 0) {
        slidesContainer.innerHTML = `<div class="slide active" style="text-align:center;"><h3>No Data to Report</h3><p>Please upload a dataset first.</p></div>`;
        document.getElementById('slide-counter').textContent = 'Slide 0 of 0';
        modal.style.display = 'flex'; return;
    }
    const { data, headers } = dataset;
    const reportDate = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    slidesContent.push(`<div style="text-align:left; padding: 2rem; height: 100%; display: flex; flex-direction: column; justify-content: center;"><h1 style="font-size: 2.5rem; color: var(--accent);">Data Analysis Report</h1><h2 style="font-size: 1.5rem; margin-top: 1rem; color: var(--text-primary);">${appState.activeDataset}</h2><p style="color: var(--text-secondary); margin-top: 2rem;">Generated by Imugi on ${reportDate}</p></div>`);
    const columnTypes = inferColumnTypes(data, headers);
    const numericalCols = Object.keys(columnTypes).filter(k => columnTypes[k] === 'numerical').length;
    const categoricalCols = Object.keys(columnTypes).filter(k => columnTypes[k] === 'categorical').length;
    slidesContent.push(`<h3>Dataset Overview</h3><table class="inspector-table" style="width: 80%; margin: 2rem auto; text-align: left; font-size: 1rem;"><tbody><tr><td style="font-weight: 600;">Filename</td><td>${appState.activeDataset}</td></tr><tr><td style="font-weight: 600;">Total Rows</td><td>${data.length.toLocaleString()}</td></tr><tr><td style="font-weight: 600;">Total Columns</td><td>${headers.length}</td></tr><tr><td style="font-weight: 600;">Numerical Cols</td><td>${numericalCols}</td></tr><tr><td style="font-weight: 600;">Categorical Cols</td><td>${categoricalCols}</td></tr></tbody></table>`);
    const summary = generateDatasetSummary(data, headers, columnTypes);
    let summaryTableHTML = `<thead style="font-size: 0.9rem;"><tr><th>Column</th><th>Type</th><th>Missing</th><th>Statistics</th></tr></thead><tbody style="font-size: 0.85rem;">`;
    headers.forEach(header => {
        const colSummary = summary[header]; let statsDetail = '';
        if (colSummary.type === 'numerical') { statsDetail = `Mean: ${colSummary.mean}, Std: ${colSummary.std}, Min: ${colSummary.min}, Max: ${colSummary.max}`; } 
        else { statsDetail = Object.entries(colSummary.top_3_frequencies).map(([k, v]) => `"${k}" (${v})`).join(', '); }
        summaryTableHTML += `<tr><td>${header}</td><td>${colSummary.type}</td><td>${colSummary.missing} (${((colSummary.missing / data.length) * 100).toFixed(1)}%)</td><td>${statsDetail || 'N/A'}</td></tr>`;
    });
    summaryTableHTML += `</tbody>`;
    slidesContent.push(`<h3>Column Statistics</h3><div style="height: 90%; overflow-y: auto; padding: 0 1rem;"><table class="inspector-table">${summaryTableHTML}</table></div>`);
    appState.terminalHistory.forEach(item => {
        if (item.type === 'chart') {
            const chartCanvas = document.getElementById(item.content.chartId);
            if (chartCanvas) { slidesContent.push(`<h3>${item.content.chartDef.options.plugins.title.text || 'Generated Visualization'}</h3><img class="chart-image" src="${chartCanvas.toDataURL('image/png', 1.0)}">`); }
        }
    });
    slidesContainer.innerHTML = slidesContent.map(content => `<div class="slide">${content}</div>`).join('');
    const slides = slidesContainer.querySelectorAll('.slide');
    const slideCounter = document.getElementById('slide-counter');
    const showSlide = (index) => { slides.forEach((s, i) => s.classList.toggle('active', i === index)); if (slideCounter) slideCounter.textContent = `Slide ${index + 1} of ${slides.length}`; };
    showSlide(slideIndex);
    
    appState.reportKeydownHandler = (e) => {
        if (e.key === 'ArrowRight' || e.key === ' ') {
            e.preventDefault(); slideIndex = (slideIndex + 1) % slides.length; showSlide(slideIndex);
        } else if (e.key === 'ArrowLeft') {
            e.preventDefault(); slideIndex = (slideIndex - 1 + slides.length) % slides.length; showSlide(slideIndex);
        } else if (e.key === 'Escape') {
            e.preventDefault(); document.getElementById('close-report-btn').click();
        }
    };
    document.addEventListener('keydown', appState.reportKeydownHandler);
    document.getElementById('next-slide-btn').onclick = () => { slideIndex = (slideIndex + 1) % slides.length; showSlide(slideIndex); };
    document.getElementById('prev-slide-btn').onclick = () => { slideIndex = (slideIndex - 1 + slides.length) % slides.length; showSlide(slideIndex); };
    modal.style.display = 'flex';
}

export async function exportReport(format) {
    const slidesContainer = document.getElementById('report-slides');
    const modalBody = slidesContainer.parentElement;
    if (!modalBody) {
        console.error("Could not find modal body to attach loading overlay.");
        return;
    }

    const loadingOverlay = document.createElement('div');
    loadingOverlay.className = 'loading-overlay';
    loadingOverlay.style.cssText = `display: flex; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000;`;
    loadingOverlay.innerHTML = '<span>Exporting... Please wait.</span>';
    modalBody.appendChild(loadingOverlay);

    try {
        const reportData = parseReportData();
        if (format === 'pptx') {
            await createPptxReport(reportData);
        } else if (format === 'pdf') {
            await createPdfReport(reportData);
        }
    } catch (error) {
        console.error("Export failed:", error);
        showNotification(error.message || "Failed to export report.", "error");
    } finally {
        if (loadingOverlay) loadingOverlay.remove();
        document.querySelector('.export-dropdown').classList.remove('open');
    }
}

function parseReportData() {
    const slides = document.getElementById('report-slides').querySelectorAll('.slide');
    const reportData = [];
    let chartHistoryIndex = 0;

    slides.forEach((slide) => {
        const h1 = slide.querySelector('h1');
        const h2 = slide.querySelector('h2');
        const h3 = slide.querySelector('h3');
        const p = slide.querySelector('p');
        const table = slide.querySelector('table');
        const img = slide.querySelector('img.chart-image');

        if (h1) {
            reportData.push({ type: 'title', title: h1.innerText, subtitle: h2.innerText, text: p.innerText });
        } else if (table && h3 && h3.innerText.includes('Overview')) {
            const rows = Array.from(table.querySelectorAll('tbody tr')).map(tr => 
                Array.from(tr.querySelectorAll('td')).map(td => td.innerText)
            );
            reportData.push({ type: 'overviewTable', title: h3.innerText, rows });
        } else if (table && h3 && h3.innerText.includes('Statistics')) {
            const head = Array.from(table.querySelectorAll('thead th')).map(th => th.innerText);
            const body = Array.from(table.querySelectorAll('tbody tr')).map(tr => 
                Array.from(tr.querySelectorAll('td')).map(td => td.innerText)
            );
            reportData.push({ type: 'statsTable', title: h3.innerText, head, body });
        } else if (img) {
            const chartHistoryItem = appState.terminalHistory.filter(item => item.type === 'chart')[chartHistoryIndex];
            if (chartHistoryItem) {
                reportData.push({ type: 'chart', title: h3 ? h3.innerText : 'Chart', chartDef: chartHistoryItem.content.chartDef });
                chartHistoryIndex++;
            }
        }
    });
    return reportData;
}

async function createPdfReport(reportData) {
    const { jsPDF } = window.jspdf;
    if (typeof jsPDF === 'undefined') {
        throw new Error("The main PDF generation library (jsPDF) failed to load.");
    }
    const doc = new jsPDF({ orientation: 'landscape' });
    if (typeof doc.autoTable !== 'function') {
        throw new Error("The PDF table library (jsPDF-AutoTable) failed to load.");
    }

    for (const [index, slide] of reportData.entries()) {
        if (index > 0) doc.addPage();
        
        switch (slide.type) {
            case 'title':
                doc.setFontSize(36).text(slide.title, doc.internal.pageSize.getWidth() / 2, 80, { align: 'center' });
                doc.setFontSize(20).text(slide.subtitle, doc.internal.pageSize.getWidth() / 2, 100, { align: 'center' });
                doc.setFontSize(12).text(slide.text, doc.internal.pageSize.getWidth() / 2, 120, { align: 'center' });
                break;
            case 'overviewTable':
            case 'statsTable':
                doc.setFontSize(18).text(slide.title, 14, 22);
                doc.autoTable({
                    head: slide.head ? [slide.head] : [],
                    body: slide.body || slide.rows,
                    startY: 30,
                });
                break;
            case 'chart':
                doc.setFontSize(18).text(slide.title, doc.internal.pageSize.getWidth() / 2, 22, { align: 'center' });
                const chart = Chart.getChart(slide.chartDef.chartId);
                if (chart) {
                    const imgData = chart.toBase64Image('image/png', 1.0);
                    const imgProps = doc.getImageProperties(imgData);
                    const imgWidth = 240;
                    const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
                    const x = (doc.internal.pageSize.getWidth() - imgWidth) / 2;
                    doc.addImage(imgData, 'PNG', x, 40, imgWidth, imgHeight);
                }
                break;
        }
    }
    doc.save(`${appState.activeDataset}_Report.pdf`);
}

async function createPptxReport(reportData) {
    if (typeof PptxGenJS === 'undefined' || typeof JSZip === 'undefined') {
        throw new Error("A required presentation library (PptxGenJS or JSZip) failed to load.");
    }
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    for (const slideData of reportData) {
        const slide = pptx.addSlide();
        switch (slideData.type) {
            case 'title':
                slide.addText(slideData.title, { x: 0.5, y: 1.5, w: '90%', h: 1, fontSize: 36, align: 'center', bold: true, color: '363636' });
                slide.addText(slideData.subtitle, { x: 0.5, y: 2.5, w: '90%', h: 1, fontSize: 24, align: 'center', color: '767676' });
                slide.addText(slideData.text, { x: 0.5, y: 3.5, w: '90%', h: 1, fontSize: 14, align: 'center', color: 'A9A9A9' });
                break;
            case 'overviewTable':
            case 'statsTable':
                slide.addText(slideData.title, { x: 0.5, y: 0.25, w: '90%', h: 0.5, fontSize: 24, bold: true });
                const tableData = slideData.head ? [slideData.head, ...slideData.body] : slideData.rows;
                slide.addTable(tableData, { x: 0.5, y: 0.8, w: '90%', autoPage: true });
                break;
            case 'chart':
                slide.addText(slideData.title, { x: 0.5, y: 0.25, w: '90%', h: 0.5, fontSize: 24, align: 'center', bold: true });
                const chartData = slideData.chartDef.data.datasets.map(ds => ({
                    name: ds.label,
                    labels: slideData.chartDef.data.labels,
                    values: ds.data
                }));
                const chartTypeMap = {
                    bar: pptx.charts.BAR,
                    line: pptx.charts.LINE,
                    pie: pptx.charts.PIE,
                    doughnut: pptx.charts.DOUGHNUT,
                    radar: pptx.charts.RADAR,
                    scatter: pptx.charts.SCATTER
                };
                const chartType = chartTypeMap[slideData.chartDef.type] || pptx.charts.BAR;
                slide.addChart(chartType, chartData, { x: 1, y: 1, w: 8, h: 4 });
                break;
        }
    }
    await pptx.writeFile({ fileName: `${appState.activeDataset}_Report.pptx` });
}